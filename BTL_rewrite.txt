## So sánh các hệ điều hành phổ biến Windows, Linux, MacOS dưới góc nhìn của người dùng và nhà phát triển

### Phần 1: Tổng quan về hệ điều hành
    **1.1: Kỷ nguyên sơ khai (1940 - 1950): Từ không gì cả, bước đệm của hệ điều hành đầu tiên**
        - Vào thuở sơ khai của máy tính, khái niệm hệ điều hành chưa hề tồn tại. Hệ điều hành máy tính mà ta sử dụng hằng ngày bây giờ là sự kết tinh của nhiều bộ óc của các kỹ sư, các nhà khoa học máy tính tài giỏi thông qua một quá trình vô tận: Gặp vấn đề -> Cải tiến để giải quyết vấn đề.  Ta có thể thấy rằng, lịch sử phát triển của hệ điều hành không phải là một chuỗi các phát minh ngẫu nhiên, mà là một quá trình tiến hóa liên tục, trong đó mỗi thế hệ mới ra đời như một giải pháp trực tiếp cho những hạn chế của thế hệ trước đó. Sự tiến hóa đó được thúc đẩy trực tiếp bởi sự phát triển của phần cứng cũng như sự thay đổi trong nhu cầu sử dụng máy tính của cá nhân.

        - Những chiếc máy tính điện tử đầu tiên trong thập niên 40 và đầu 50 hoàn toàn không có hệ điều hành. Các máy tính như ENIAC và UNIVAC hoạt động trên "phần cứng trần". Các lập trình viên phải tương tác trực tiếp với phần cứng của máy thông qua các quy trình thủ công tốn nhiều công sức, sử dụng các công tắc vật lý, dây cắm và thẻ đục lỗ để nhập chương trình và dữ liệu. Mỗi công việc yêu cầu một quá trình thiết lập thủ công hoàn chỉnh, từ việc nạp chương trình đến cấu hình các thiết bị ngoại vi... Nút thắt cổ chai quan trọng trong giai đoạn này không chỉ là tốc độ tính toán của máy, mà còn là "thời gian thiết lập" (setup time) khổng lồ giữa các công việc. Quá trình chuyển đổi từ một chương trình này sang chương trình tiếp theo là một công việc hoàn toàn thủ công, đó chính là một lỗ hổng rất lớn về kinh tế. Các phần cứng trị giá hàng triệu đô thường xuyên ở trạng thái không hoạt động trong những khoảng thời gian đáng kể. Sự thiếu hiệu quả về mặt kinh tế này là chất xúc tác chính cho sự ra đời của những hệ điều hành sơ khai đầu tiên. Nhu cầu tối đa hóa việc sử dụng "tài sản đắt đỏ" này đã tạo ra một áp lực mạnh mẽ lên các kỹ sư nhằm tự động hóa quy trình làm việc của máy tính, đặt nền móng cho cuộc cách mạng hệ điều hành sẽ diễn ra sau đó.

    **1.2: Tự động hóa - Hệ thống xử lí theo chuỗi**
        - Sự ra đời mang tính bước ngoặt của của ***Hệ Điều Hành Đầu Tiên: GM-NAA I/O***
            + Năm 1956, một cột mốc quan trọng đã được thiết lập khi General Motors (GM) và North American Aviation (NAA) hợp tác phát triển GM-NAA I/O cho máy tính IBM 704. Hệ thống này được công nhận rộng rãi là hệ điều hành đầu tiên trên thế giới. Nó được tạo ra bởi Robert L. Patrick của GM và Owen Mock của NAA, dựa trên một "trình giám sát hệ thống" (system monitor) trước đó được phát triển vào năm 1955 cho máy IBM 701
            + Cốt lõi của GM-NAA I/O là một "trình giám sát thường trú" (resident monitor), một chương trình nhỏ luôn nằm trong bộ nhớ của máy tính. Chức năng chính của nó là tự động hóa quy trình làm việc. Thay vì dừng lại sau khi một công việc kết thúc, trình giám sát sẽ tự động nạp và thực thi chương trình tiếp theo trong một chuỗi, hay còn gọi là một "lô" (batch). Quy trình làm việc đã thay đổi, các lập trình viên sẽ gửi các công việc của họ (dưới dạng thẻ đục lỗ hoặc băng từ) cho một người vận hành máy tính. Người vận hành sau đó sẽ nhóm các công việc có nhu cầu tương tự lại với nhau thành các chuỗi hợp lý để máy tính xử lý.
                + VD: Ví dụ, tất cả các công việc liên quan đến biên dịch FORTRAN sẽ được gộp chung lại, trình giám sát sau đó sẽ quản lý việc thực thi toàn bộ chuỗi này mà không cần sự can thiệp của con người.
            **TODO: Kết luận**
 
    **1.3: Đa Chương trình (Multiprograming) và Hệ Thống Chia Sẻ Thời Gian (Time-Sharing System)**
        - Sau khi giải quyết được vấn đề thời gian chết giữa các công việc, một nút thắt cổ chai mới về hiệu suất đã xuất hiện. Sau 10 năm, máy tính đã mạnh lên theo cấp số nhân, Bộ xử lý trung tâm (CPU) đã trở nên quá mạnh so với các chương trình thông thường, các chương trình bao gồm cả các phép tính CPU rất nhanh nhưng các hoạt động I/O của các thiết bị ngoại vi lại chậm hơn rất nhiều. Ví dụ khi CPU đã xử lí xong và đưa ra kết quả thì máy in vẫn còn xử lí rất lâu mới có thể in kết quả ra giấy. Điều này dẫn đến CPU phải đợi, gây lãng phí hiệu năng rất lớn. Bước nhảy vọt tiếp theo trong quá trình tiến hóa của hệ điều hành là chuyển từ xử lý theo chuỗi tuần tự sang việc thực thi đồng thời các chương trình.

        - **Đa chương trình - Giữ cho CPU luôn bận rộn**
            + Giải pháp cho vấn đề trên là cơ chế Đa Chương Trình 
            (Multiprograming) - giữ nhiều công việc được nạp vào bộ nhớ cùng một lúc. Cơ chế kỹ thuật của nó rất độc đáo và khéo léo: Khi có công việc đang chạy (Tiến trình A) thực hiện một hoạt động I/O (Input/Output) bị chậm, hệ điều hành sẽ ngắt nó, lưu lại trạng thái của nó và chuyển sự chú ý của CPU sang một công việc khác đã sẵn sàng trong bộ nhớ (Tiến trình B). Khi hoạt động I/O của Tiến trình A hoàn tất, nó sẽ báo hiệu cho hệ điều hành, và hệ điều hành có thể lên lịch cho nó chạy tiếp sau. Sự chuyển đổi liên tục này giữ cho CPU liên tục bận rộn, tăng đáng kể hiệu suất sử dụng tổng thể của hệ thống.
            + Sự thay đổi này đã mang lại những trách nhiệm mới cho hệ điều hành. Nó không còn chỉ là một trình tự động hóa công việc đơn giản mà đã trở thành một trình quản lý tài nguyên phức tạp, chịu trách nhiệm lên lịch công việc cho CPU, quản lý bộ nhớ và cung cấp cơ chế bảo vệ để ngăn các công việc xung đột với nhau.
		- Ví dụ tiêu biểu cho cơ chế này là Hệ điều hành IBM OS/360
			+ Được công bố vào năm 1964 cho dòng phần cứng System/360, mang tính cách mạng, OS/360 được thiết kế như một hệ điều hành đa năng, có khả năng hỗ trợ cả các ứng dụng khoa học và thương mại. Đây là một dự án mang tính bước ngoặt, lần đầu tiên tách biệt phần mềm khỏi phần cứng, cho phép các chương trình chạy trên một họ máy tính tương thích mà không cần sửa đổi. OS/360 đã hiện thực hóa khái niệm đa chương trên quy mô lớn với các biến thể khác nhau:
				++ PCP (Primary Control Program): Một phiên bản đơn giản, đơn nhiệm dành cho các máy có bộ nhớ thấp, về cơ bản là sự tiếp nối của mô hình xử lý theo lô.
				++ MFT (Multiprogramming with a Fixed number of Tasks): Triển khai đa chương bằng cách chia bộ nhớ thành một số lượng phân vùng (partition) cố định khi khởi động hệ thống. Mỗi phân vùng có thể chứa một công việc. Cách tiếp cận này tuy ổn định nhưng không linh hoạt và có thể lãng phí bộ nhớ nếu một công việc không sử dụng hết phân vùng của nó.
				++ MVT (Multiprogramming with a Variable number of Tasks): Phiên bản tiên tiến nhất. Nó coi bộ nhớ như một vùng chung duy nhất, cấp phát các vùng (region) có kích thước thay đổi cho các công việc khi cần. Điều này hiệu quả hơn về mặt sử dụng bộ nhớ so với MFT nhưng lại giới thiệu một vấn đề mới: sự phân mảnh bộ nhớ (memory fragmentation), nơi các khối bộ nhớ trống bị phân tán, không đủ lớn để nạp một công việc mới mặc dù tổng dung lượng trống là đủ. 
            - Một ví dụ tiêu biều khác là CTSS của MIT
                + Trong khi IBM đang phát triển OS/360, một hướng đi khác đã được theo đuổi tại MIT. Hệ thống Chia sẻ Thời gian Tương thích (CTSS), được trình diễn lần đầu vào năm 1961, có một mục tiêu khác: tối ưu hóa năng suất của lập trình viên.
                + CTSS (Compatible Time-Sharing System) cho phép nhiều người dùng tương tác với máy tính từ các thiết bị đầu cuối từ xa. Hệ điều hành lúc này sẽ cấp cho mỗi người dùng một phần CPU nhỏ theo kiểu xoay vòng (round-robin). Việc chuyển đổi diễn này ra nhanh đến mức tạo ra ảo giác rằng mỗi người dùng đều có một máy tính riêng cho mình. Lúc này mỗi người dùng sẽ chạy chương trình của riêng mình, nhiều chương trình sẽ được chạy cùng một lúc, tối ưu đối đa hiệu năng của máy.
                + Tuy nhiên để thực hiện điều này, CTSS đòi hỏi những sửa đổi phần cứng đáng kể cho máy IBM 7094, các kĩ sư tại MIT đã phải thiết kế thêm một vài cơ chế:
                    ++ Bảo vệ bộ nhớ: Ngăn không cho tiến trình (process) của người dùng xung đột với nhau đồng thời tăng cường bảo mật, tránh cho người dùng này can thiệp vào tiến trình của người khác.
                    TODO: ...
                    ++ Tái định vị thanh ghi (relocation registers):
                    ++ Một bộ đếm thời gian ngắt quãng (interval timer):
                + CTSS cũng đi tiên phong trong các khái niệm mà ngày nay chúng ta coi là điều cơ bản, như thư mục tệp tin cho mỗi người dùng, đăng nhập bằng mật khẩu và hệ thống nhắn tin giữa người dùng (tiền thân của email).
        - Như vậy ta có thể thấy rằng trong những năm 1960 đã chứng kiến sự phân tách triết học lớn đầu tiên trong thiết kế hệ điều hành, tạo ra hai con đường tiến hóa riêng biệt. Đa chương trình, như trong OS/360, về cơ bản là lấy máy tính làm trung tâm, tập trung vào việc tối đa hóa phần cứng cho xủ lí theo chuỗi. Ngược lại, chia sẻ thời gian, như trong CTSS, lại lấy con người làm trung tâm, tập trung vào việc giảm thiểu thời gian của nhà phát triển và cho phép máy tính tương tác. Sự phân chia này không chỉ là một sự khác biệt về kỹ thuật; nó phản ánh hai quan điểm khác nhau về mục đích của máy tính. Một bên xem máy tính như một nhà máy, sản xuất các kết quả tính toán, nơi độ hiệu quả được đo bằng số lượng công việc hoàn thành mỗi giờ. Bên kia xem máy tính như một công cụ cộng tác để tăng cường trí tuệ con người, nơi hiệu quả được đo bằng việc giảm thời gian của lập trình viên và khả năng tạo ra các ứng dụng tương tác mới. Sự phân chia triết học này sẽ định hình các cuộc tranh luận và sự phát triển của hệ điều hành trong nhiều thập kỷ tiếp theo, trực tiếp dẫn đến việc tạo ra các hệ thống như Multics (Thế hệ kế tiếp của CTSS) và cải tiến của nó, Unix (môi trường tối thượng của lập trình viên).

	**1.4: Multics tới Unix - Từ Khát vọng tới sự Thực dụng**
		- Đây là hai trong số những hệ điều hành có ảnh hưởng nhất từng được tạo ra Multics, một dự án đầy tham vọng và phức tạp nhằm biến máy tính thành một tiện ích công cộng, và Unix, người kế nhiệm thực dụng và tối giản của nó, nổi lên từ sự thất bại được nhận thức của Multics và tiếp tục định hình thế giới máy tính hiện đại.
		
		** Multics (MULTiplexed Information and Computing Service)**
			- Là một dự án hợp tác giữa MIT, General Electric (GE) và Bell Labs bắt đầu vào năm 1964, Multics (Multiplexed Information and Computing Service) là người kế thừa về mặt khái niệm của CTSS nhưng với mục tiêu lớn hơn: cung cấp năng lực tính toán đáng tin cậy và liên tục cho nhiều người dùng cùng một lúc. Multics là một kho tàng các ý tưởng tiên phong, nhiều trong số đó đã trở thành tiêu chuẩn ngày nay:
				+ Hệ Thống Tệp Tin Phân Cấp (Hierarchical File System): Multics là hệ điều hành đầu tiên triển khai một hệ thống tệp tin có cấu trúc cây, với tên tệp có độ dài gần như tùy ý và hỗ trợ các liên kết tượng trưng (symbolic links).
				+ Kho Lưu Trữ Một Cấp (Single-Level Store): Một ý tưởng mang tính cách mạng đã xóa bỏ sự phân biệt rõ ràng giữa tệp tin và bộ nhớ tiến trình. Việc truy cập một tệp tin cũng giống hệt như truy cập bộ nhớ; hệ điều hành tự động xử lý việc phân trang dữ liệu từ đĩa khi cần thiết, loại bỏ các lệnh gọi I/O tường minh trong chương trình của người dùng.
				+ Liên Kết Động (Dynamic Linking): Các tiến trình có thể liên kết đến các thư viện dùng chung trong thời gian chạy, đảm bảo chúng luôn sử dụng phiên bản mới nhất và tiết kiệm bộ nhớ.
				+ Bảo Mật Dựa trên Vòng (Ring-Based Security): Được thiết kế ngay từ đầu để trở thành một hệ thống an toàn, Multics sử dụng một cấu trúc vòng đa cấp được phần cứng hỗ trợ để bảo vệ các tài nguyên hệ thống khỏi các chương trình người dùng.
			- Mặc dù có những ý tưởng xuất sắc, dự án đã bị sa lầy bởi chính sự phức tạp và tham vọng của nó. Hệ thống trở nên quá lớn, chậm chạp và đòi hỏi phần cứng chuyên dụng đắt tiền (máy GE 645) để chạy. Thất vọng vì không có một hệ thống hoạt động hiệu quả trong tầm tay, ban lãnh đạo của Bell Labs đã quyết định rút khỏi dự án vào năm 1969.

		**Sự Ra Đời của Unix**
			- Các nhà nghiên cứu của Bell Labs đã làm việc trên Multics, đặc biệt là Ken Thompson và Dennis Ritchie nhớ đến sự hứa hẹn về môi trường mà Multics đã hứa hẹn, nhưng lại e dè sự phức tạp của nó. Sau khi Bell Labs rút lui khỏi dự án Multics, Thompson bắt đầu làm việc trên một hệ điều hành mới, đơn giản hơn nhiều trên một chiếc máy tính PDP-7 "ít được sử dụng", một cỗ máy nhỏ hơn và yếu hơn rất nhiều so với mainframe của Multics. Cái tên "Unix" là một cách chơi chữ của "Multics", ngụ ý một cách tiếp cận đơn giản hơn, "uniplexed".
			- Triết Lý Unix và Ngôn Ngữ C
				+ Sự ra đời của Unix không chỉ là một thành tựu kỹ thuật mà còn là sự ra đời của một triết lý thiết kế phần mềm mạnh mẽ.
					++ Triết lý: Triết lý cốt lõi, được Doug McIlroy ghi lại, là "làm cho mỗi chương trình thực hiện tốt một việc duy nhất". Các chương trình được thiết kế như những "công cụ" nhỏ, chỉ có mục đích duy nhất, nhưng lại có thể được kết hợp mạnh mẽ với nhau bằng cách sử dụng pipes (đường ống), chuyển đầu ra của chương trình này thành đầu vào của chương trình khác. Các luồng văn bản đơn giản được sử dụng làm giao diện phổ quát. Đây là một sự từ chối trực tiếp đối với thiết kế nguyên khối của các hệ thống như Multics.
					++ Ngôn ngữ C: Năm 1973, một bước đi mang tính lịch sử đã được thực hiện: nhân Unix được viết lại bằng một ngôn ngữ lập trình bậc cao mới do Dennis Ritchie tạo ra, có tên là C. Đây là một bước tiến vĩ đại. Việc viết một hệ điều hành bằng ngôn ngữ bậc cao thay vì hợp ngữ (assembly) đã làm cho nó trở nên di động (portable) - nó có thể được biên dịch lại để chạy trên các phần cứng máy tính khác nhau mà không cần phải viết lại cả hệ thống. Tính di động này chính là chìa khóa cho sự phát triển bùng nổ và tầm ảnh hưởng sâu rộng của Unix.


1.2: 
