## So sánh các hệ điều hành phổ biến Windows, Linux, MacOS dưới góc nhìn của người dùng và nhà phát triển

### Phần 1: Tổng quan về hệ điều hành
1.1: Lịch sử phát triển
    **1.1.1: Kỷ nguyên sơ khai (1940 - 1950): Từ không gì cả, bước đệm của hệ điều hành đầu tiên**
        - Vào thuở sơ khai của máy tính, khái niệm hệ điều hành chưa hề tồn tại. Hệ điều hành máy tính mà ta sử dụng hằng ngày bây giờ là sự kết tinh của nhiều bộ óc của các kỹ sư, các nhà khoa học máy tính tài giỏi thông qua một quá trình vô tận: Gặp vấn đề -> Cải tiến để giải quyết vấn đề.  Ta có thể thấy rằng, lịch sử phát triển của hệ điều hành không phải là một chuỗi các phát minh ngẫu nhiên, mà là một quá trình tiến hóa liên tục, trong đó mỗi thế hệ mới ra đời như một giải pháp trực tiếp cho những hạn chế của thế hệ trước đó. Sự tiến hóa đó được thúc đẩy trực tiếp bởi sự phát triển của phần cứng cũng như sự thay đổi trong nhu cầu sử dụng máy tính của cá nhân.

        - Những chiếc máy tính điện tử đầu tiên trong thập niên 40 và đầu 50 hoàn toàn không có hệ điều hành. Các máy tính như ENIAC và UNIVAC hoạt động trên "phần cứng trần". Các lập trình viên phải tương tác trực tiếp với phần cứng của máy thông qua các quy trình thủ công tốn nhiều công sức, sử dụng các công tắc vật lý, dây cắm và thẻ đục lỗ để nhập chương trình và dữ liệu. Mỗi công việc yêu cầu một quá trình thiết lập thủ công hoàn chỉnh, từ việc nạp chương trình đến cấu hình các thiết bị ngoại vi... Nút thắt cổ chai quan trọng trong giai đoạn này không chỉ là tốc độ tính toán của máy, mà còn là "thời gian thiết lập" (setup time) khổng lồ giữa các công việc. Quá trình chuyển đổi từ một chương trình này sang chương trình tiếp theo là một công việc hoàn toàn thủ công, đó chính là một lỗ hổng rất lớn về kinh tế. Các phần cứng trị giá hàng triệu đô thường xuyên ở trạng thái không hoạt động trong những khoảng thời gian đáng kể. Sự thiếu hiệu quả về mặt kinh tế này là chất xúc tác chính cho sự ra đời của những hệ điều hành sơ khai đầu tiên. Nhu cầu tối đa hóa việc sử dụng "tài sản đắt đỏ" này đã tạo ra một áp lực mạnh mẽ lên các kỹ sư nhằm tự động hóa quy trình làm việc của máy tính, đặt nền móng cho cuộc cách mạng hệ điều hành sẽ diễn ra sau đó.

    **1.1.2: Tự động hóa - Hệ thống xử lí theo chuỗi**
        - Sự ra đời mang tính bước ngoặt của của ***Hệ Điều Hành Đầu Tiên: GM-NAA I/O***
            + Năm 1956, một cột mốc quan trọng đã được thiết lập khi General Motors (GM) và North American Aviation (NAA) hợp tác phát triển GM-NAA I/O cho máy tính IBM 704. Hệ thống này được công nhận rộng rãi là hệ điều hành đầu tiên trên thế giới. Nó được tạo ra bởi Robert L. Patrick của GM và Owen Mock của NAA, dựa trên một "trình giám sát hệ thống" (system monitor) trước đó được phát triển vào năm 1955 cho máy IBM 701
            + Cốt lõi của GM-NAA I/O là một "trình giám sát thường trú" (resident monitor), một chương trình nhỏ luôn nằm trong bộ nhớ của máy tính. Chức năng chính của nó là tự động hóa quy trình làm việc. Thay vì dừng lại sau khi một công việc kết thúc, trình giám sát sẽ tự động nạp và thực thi chương trình tiếp theo trong một chuỗi, hay còn gọi là một "lô" (batch). Quy trình làm việc đã thay đổi, các lập trình viên sẽ gửi các công việc của họ (dưới dạng thẻ đục lỗ hoặc băng từ) cho một người vận hành máy tính. Người vận hành sau đó sẽ nhóm các công việc có nhu cầu tương tự lại với nhau thành các chuỗi hợp lý để máy tính xử lý.
                + VD: Ví dụ, tất cả các công việc liên quan đến biên dịch FORTRAN sẽ được gộp chung lại, trình giám sát sau đó sẽ quản lý việc thực thi toàn bộ chuỗi này mà không cần sự can thiệp của con người.
            **TODO: Kết luận**
 
    **1.1.3: Đa Chương trình (Multiprograming) và Hệ Thống Chia Sẻ Thời Gian (Time-Sharing System)**
        - Sau khi giải quyết được vấn đề thời gian chết giữa các công việc, một nút thắt cổ chai mới về hiệu suất đã xuất hiện. Sau 10 năm, máy tính đã mạnh lên theo cấp số nhân, Bộ xử lý trung tâm (CPU) đã trở nên quá mạnh so với các chương trình thông thường, các chương trình bao gồm cả các phép tính CPU rất nhanh nhưng các hoạt động I/O của các thiết bị ngoại vi lại chậm hơn rất nhiều. Ví dụ khi CPU đã xử lí xong và đưa ra kết quả thì máy in vẫn còn xử lí rất lâu mới có thể in kết quả ra giấy. Điều này dẫn đến CPU phải đợi, gây lãng phí hiệu năng rất lớn. Bước nhảy vọt tiếp theo trong quá trình tiến hóa của hệ điều hành là chuyển từ xử lý theo chuỗi tuần tự sang việc thực thi đồng thời các chương trình.

        - **Đa chương trình - Giữ cho CPU luôn bận rộn**
            + Giải pháp cho vấn đề trên là cơ chế Đa Chương Trình 
            (Multiprograming) - giữ nhiều công việc được nạp vào bộ nhớ cùng một lúc. Cơ chế kỹ thuật của nó rất độc đáo và khéo léo: Khi có công việc đang chạy (Tiến trình A) thực hiện một hoạt động I/O (Input/Output) bị chậm, hệ điều hành sẽ ngắt nó, lưu lại trạng thái của nó và chuyển sự chú ý của CPU sang một công việc khác đã sẵn sàng trong bộ nhớ (Tiến trình B). Khi hoạt động I/O của Tiến trình A hoàn tất, nó sẽ báo hiệu cho hệ điều hành, và hệ điều hành có thể lên lịch cho nó chạy tiếp sau. Sự chuyển đổi liên tục này giữ cho CPU liên tục bận rộn, tăng đáng kể hiệu suất sử dụng tổng thể của hệ thống.
            + Sự thay đổi này đã mang lại những trách nhiệm mới cho hệ điều hành. Nó không còn chỉ là một trình tự động hóa công việc đơn giản mà đã trở thành một trình quản lý tài nguyên phức tạp, chịu trách nhiệm lên lịch công việc cho CPU, quản lý bộ nhớ và cung cấp cơ chế bảo vệ để ngăn các công việc xung đột với nhau.
		- Ví dụ tiêu biểu cho cơ chế này là Hệ điều hành IBM OS/360
			+ Được công bố vào năm 1964 cho dòng phần cứng System/360, mang tính cách mạng, OS/360 được thiết kế như một hệ điều hành đa năng, có khả năng hỗ trợ cả các ứng dụng khoa học và thương mại. Đây là một dự án mang tính bước ngoặt, lần đầu tiên tách biệt phần mềm khỏi phần cứng, cho phép các chương trình chạy trên một họ máy tính tương thích mà không cần sửa đổi. OS/360 đã hiện thực hóa khái niệm đa chương trên quy mô lớn với các biến thể khác nhau:
				++ PCP (Primary Control Program): Một phiên bản đơn giản, đơn nhiệm dành cho các máy có bộ nhớ thấp, về cơ bản là sự tiếp nối của mô hình xử lý theo lô.
				++ MFT (Multiprogramming with a Fixed number of Tasks): Triển khai đa chương bằng cách chia bộ nhớ thành một số lượng phân vùng (partition) cố định khi khởi động hệ thống. Mỗi phân vùng có thể chứa một công việc. Cách tiếp cận này tuy ổn định nhưng không linh hoạt và có thể lãng phí bộ nhớ nếu một công việc không sử dụng hết phân vùng của nó.
				++ MVT (Multiprogramming with a Variable number of Tasks): Phiên bản tiên tiến nhất. Nó coi bộ nhớ như một vùng chung duy nhất, cấp phát các vùng (region) có kích thước thay đổi cho các công việc khi cần. Điều này hiệu quả hơn về mặt sử dụng bộ nhớ so với MFT nhưng lại giới thiệu một vấn đề mới: sự phân mảnh bộ nhớ (memory fragmentation), nơi các khối bộ nhớ trống bị phân tán, không đủ lớn để nạp một công việc mới mặc dù tổng dung lượng trống là đủ. 
            - Một ví dụ tiêu biều khác là CTSS của MIT
                + Trong khi IBM đang phát triển OS/360, một hướng đi khác đã được theo đuổi tại MIT. Hệ thống Chia sẻ Thời gian Tương thích (CTSS), được trình diễn lần đầu vào năm 1961, có một mục tiêu khác: tối ưu hóa năng suất của lập trình viên.
                + CTSS (Compatible Time-Sharing System) cho phép nhiều người dùng tương tác với máy tính từ các thiết bị đầu cuối từ xa. Hệ điều hành lúc này sẽ cấp cho mỗi người dùng một phần CPU nhỏ theo kiểu xoay vòng (round-robin). Việc chuyển đổi diễn này ra nhanh đến mức tạo ra ảo giác rằng mỗi người dùng đều có một máy tính riêng cho mình. Lúc này mỗi người dùng sẽ chạy chương trình của riêng mình, nhiều chương trình sẽ được chạy cùng một lúc, tối ưu đối đa hiệu năng của máy.
                + Tuy nhiên để thực hiện điều này, CTSS đòi hỏi những sửa đổi phần cứng đáng kể cho máy IBM 7094, các kĩ sư tại MIT đã phải thiết kế thêm một vài cơ chế:
                    ++ Bảo vệ bộ nhớ: Ngăn không cho tiến trình (process) của người dùng xung đột với nhau đồng thời tăng cường bảo mật, tránh cho người dùng này can thiệp vào tiến trình của người khác.
                    TODO: ...
                    ++ Tái định vị thanh ghi (relocation registers):
                    ++ Một bộ đếm thời gian ngắt quãng (interval timer):
                + CTSS cũng đi tiên phong trong các khái niệm mà ngày nay chúng ta coi là điều cơ bản, như thư mục tệp tin cho mỗi người dùng, đăng nhập bằng mật khẩu và hệ thống nhắn tin giữa người dùng (tiền thân của email).
        - Như vậy ta có thể thấy rằng trong những năm 1960 đã chứng kiến sự phân tách triết học lớn đầu tiên trong thiết kế hệ điều hành, tạo ra hai con đường tiến hóa riêng biệt. 
1.2: 
