## So sánh các hệ điều hành phổ biến Windows, Linux, MacOS dưới góc nhìn của người dùng và nhà phát triển

### Phần 1: Tổng quan về hệ điều hành
1.1: Lịch sử phát triển
    **1.1.1: Kỷ nguyên sơ khai (1940 - 1950): Từ không gì cả, bước đệm của hệ điều hành đầu tiên**

        - Vào thuở sơ khai của máy tính, khái niệm hệ điều hành chưa hề tồn tại. Hệ điều hành máy tính mà ta sử dụng hằng ngày bây giờ là sự kết tinh của nhiều bộ óc của các kỹ sư, các nhà khoa học máy tính tài giỏi thông qua một quá trình vô tận: Gặp vấn đề -> Cải tiến để giải quyết vấn đề.  Ta có thể thấy rằng, lịch sử phát triển của hệ điều hành không phải là một chuỗi các phát minh ngẫu nhiên, mà là một quá trình tiến hóa liên tục, trong đó mỗi thế hệ mới ra đời như một giải pháp trực tiếp cho những hạn chế của thế hệ trước đó. Sự tiến hóa đó được thúc đẩy trực tiếp bởi sự phát triển của phần cứng cũng như sự thay đổi trong nhu cầu sử dụng máy tính của cá nhân.

        - Những chiếc máy tính điện tử đầu tiên trong thập niên 40 và đầu 50 hoàn toàn không có hệ điều hành. Các máy tính như ENIAC và UNIVAC hoạt động trên "phần cứng trần". Các lập trình viên phải tương tác trực tiếp với phần cứng của máy thông qua các quy trình thủ công tốn nhiều công sức, sử dụng các công tắc vật lý, dây cắm và thẻ đục lỗ để nhập chương trình và dữ liệu. Mỗi công việc yêu cầu một quá trình thiết lập thủ công hoàn chỉnh, từ việc nạp chương trình đến cấu hình các thiết bị ngoại vi... Nút thắt cổ chai quan trọng trong giai đoạn này không chỉ là tốc độ tính toán của máy, mà còn là "thời gian thiết lập" (setup time) khổng lồ giữa các công việc. Quá trình chuyển đổi từ một chương trình này sang chương trình tiếp theo là một công việc hoàn toàn thủ công, đó chính là một lỗ hổng rất lớn về kinh tế. Các phần cứng trị giá hàng triệu đô thường xuyên ở trạng thái không hoạt động trong những khoảng thời gian đáng kể. Sự thiếu hiệu quả về mặt kinh tế này là chất xúc tác chính cho sự ra đời của những hệ điều hành sơ khai đầu tiên. Nhu cầu tối đa hóa việc sử dụng "tài sản đắt đỏ" này đã tạo ra một áp lực mạnh mẽ lên các kỹ sư nhằm tự động hóa quy trình làm việc của máy tính, đặt nền móng cho cuộc cách mạng hệ điều hành sẽ diễn ra sau đó.

    **1.1.2: Tự động hóa - Hệ thống xử lí theo chuỗi**
        - Sự ra đời mang tính bước ngoặt của của ***Hệ Điều Hành Đầu Tiên: GM-NAA I/O***
            + Năm 1956, một cột mốc quan trọng đã được thiết lập khi General Motors (GM) và North American Aviation (NAA) hợp tác phát triển GM-NAA I/O cho máy tính IBM 704. Hệ thống này được công nhận rộng rãi là hệ điều hành đầu tiên trên thế giới. Nó được tạo ra bởi Robert L. Patrick của GM và Owen Mock của NAA, dựa trên một "trình giám sát hệ thống" (system monitor) trước đó được phát triển vào năm 1955 cho máy IBM 701
            + Cốt lõi của GM-NAA I/O là một "trình giám sát thường trú" (resident monitor), một chương trình nhỏ luôn nằm trong bộ nhớ của máy tính. Chức năng chính của nó là tự động hóa quy trình làm việc. Thay vì dừng lại sau khi một công việc kết thúc, trình giám sát sẽ tự động nạp và thực thi chương trình tiếp theo trong một chuỗi, hay còn gọi là một "lô" (batch). Quy trình làm việc đã thay đổi, các lập trình viên sẽ gửi các công việc của họ (dưới dạng thẻ đục lỗ hoặc băng từ) cho một người vận hành máy tính. Người vận hành sau đó sẽ nhóm các công việc có nhu cầu tương tự lại với nhau thành các chuỗi hợp lý để máy tính xử lý.
                + VD: Ví dụ, tất cả các công việc liên quan đến biên dịch FORTRAN sẽ được gộp chung lại, trình giám sát sau đó sẽ quản lý việc thực thi toàn bộ chuỗi này mà không cần sự can thiệp của con người.
            **TODO: Kết luận**
 
    **1.1.3: Đa Chương trình (Multiprograming) và Hệ Thống Chia Sẻ Thời Gian (Time-Sharing System)**
        - Sau khi giải quyết được vấn đề thời gian chết giữa các công việc, một nút thắt cổ chai mới về hiệu suất đã xuất hiện. Sau 10 năm, máy tính đã mạnh lên theo cấp số nhân, Bộ xử lý trung tâm (CPU) đã trở nên quá mạnh so với các chương trình thông thường dẫn đến ngay cả khi một chương trình đang chạy thì phần lớn CPU không cần phải hoạt động. Bước nhảy vọt tiếp theo trong quá trình tiến hóa của hệ điều hành là chuyển từ xử lý theo chuỗi tuần tự sang thực thi đồng thời.

        - **Đa chương trình - Giữ cho CPU luôn bận rộn**
            + Giải pháp cho vấn đề trên là cơ chế Đa Chương Trình (Multiprograming) - giữ nhiều công việc được nạp vào bộ nhớ cùng một lúc. Cơ chế kỹ thuật của nó rất độc đáo và khéo léo: khi có công việc đang chạy (Tiến trình A) thực hiện một hoạt động I/O (Input/Output) chậm, hệ điều hành sẽ ngắt nó, lưu lại trạng thái của nó và chuyển sự chú ý của CPU sang một công việc khác đã sẵn sàng trong bộ nhớ (Tiến trình B). Khi hoạt động I/O của Tiến trình A hoàn tất, nó sẽ báo hiệu cho hệ điều hành, và hệ điều hành có thể lên lịch cho nó chạy tiếp sau. Sự chuyển đổi liên tục này giữ cho CPU liên tục bận rộn, tăng đáng kể hiệu suất sử dụng tổng thể của hệ thống.
            + Sự thay đổi này đã mang lại những trách nhiệm mới cho hệ điều hành. Nó không còn chỉ là một trình tự động hóa công việc đơn giản mà đã trở thành một trình quản lý tài nguyên phức tạp, chịu trách nhiệm lên lịch công việc cho CPU, quản lý bộ nhớ và cung cấp cơ chế bảo vệ để ngăn các công việc xung đột với nhau.
1.2: 
